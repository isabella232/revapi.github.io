<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractIncludeExcludeFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Revapi Java Extension</a> &gt; <a href="index.source.html" class="el_package">org.revapi.java.filters</a> &gt; <span class="el_source">AbstractIncludeExcludeFilter.java</span></div><h1>AbstractIncludeExcludeFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Lukas Krejci
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 *
 */
package org.revapi.java.filters;

import static java.util.stream.Collectors.toList;

import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.jboss.dmr.ModelNode;
import org.revapi.AnalysisContext;
import org.revapi.Element;
import org.revapi.ElementFilter;
import org.revapi.java.spi.JavaAnnotationElement;
import org.revapi.java.spi.JavaElement;
import org.revapi.java.spi.JavaModelElement;

/**
 * @author Lukas Krejci
 * @since 0.7.0
 */
abstract class AbstractIncludeExcludeFilter implements ElementFilter {
    private final String configurationRootPath;
    private final String[] configurationRoot;
    private final String schemaPath;
<span class="fc" id="L51">    private final IdentityHashMap&lt;Object, InclusionState&gt; elementResults = new IdentityHashMap&lt;&gt;();</span>
    protected Predicate&lt;String&gt; includeTest;
    protected Predicate&lt;String&gt; excludeTest;
    protected boolean doNothing;

<span class="fc" id="L56">    protected AbstractIncludeExcludeFilter(String configurationRootPath, String schemaPath) {</span>
<span class="fc" id="L57">        this.configurationRootPath = configurationRootPath;</span>
<span class="fc" id="L58">        this.configurationRoot = configurationRootPath.split(&quot;\\.&quot;);</span>
<span class="fc" id="L59">        this.schemaPath = schemaPath;</span>
<span class="fc" id="L60">    }</span>

    protected Predicate&lt;String&gt; composeTest(List&lt;String&gt; fullMatches, List&lt;Pattern&gt; patterns) {
<span class="pc bpc" id="L63" title="1 of 4 branches missed.">        if (fullMatches != null &amp;&amp; fullMatches.size() &gt; 0) {</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            return s -&gt; Collections.binarySearch(fullMatches, s) &gt;= 0;</span>
<span class="pc bpc" id="L65" title="1 of 4 branches missed.">        } else if (patterns != null &amp;&amp; patterns.size() &gt; 0) {</span>
<span class="fc" id="L66">            return s -&gt; patterns.stream().anyMatch(p -&gt; p.matcher(s).matches());</span>
        } else {
<span class="fc" id="L68">            return null;</span>
        }
    }

    @Override
    public void close() throws Exception {
<span class="fc" id="L74">        elementResults.clear();</span>
<span class="fc" id="L75">    }</span>

    @Override
    public @Nullable
    String[] getConfigurationRootPaths() {
<span class="fc" id="L80">        return new String[]{configurationRootPath};</span>
    }

    @Override
    public Reader getJSONSchema(@Nonnull String configurationRootPath) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (this.configurationRootPath.equals(configurationRootPath)) {</span>
<span class="nc" id="L86">            return new InputStreamReader(getClass().getResourceAsStream(schemaPath), Charset.forName(&quot;UTF-8&quot;));</span>
        } else {
<span class="nc" id="L88">            return null;</span>
        }
    }


    @Override
    public void initialize(@Nonnull AnalysisContext analysisContext) {
<span class="fc" id="L95">        ModelNode root = analysisContext.getConfiguration().get(configurationRoot);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (!root.isDefined()) {</span>
<span class="fc" id="L97">            doNothing = true;</span>
<span class="fc" id="L98">            return;</span>
        }

<span class="fc" id="L101">        ModelNode regex = root.get(&quot;regex&quot;);</span>
<span class="pc bpc" id="L102" title="1 of 4 branches missed.">        boolean regexes = regex.isDefined() &amp;&amp; regex.asBoolean();</span>

<span class="fc" id="L104">        List&lt;String&gt; fullMatches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L105">        List&lt;Pattern&gt; patterns = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L107">        readMatches(root.get(&quot;exclude&quot;), regexes, fullMatches, patterns);</span>

<span class="fc" id="L109">        validateConfiguration(true, fullMatches, patterns, regexes);</span>

<span class="fc" id="L111">        this.excludeTest = composeTest(fullMatches, patterns);</span>

<span class="fc" id="L113">        fullMatches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L114">        patterns = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L116">        readMatches(root.get(&quot;include&quot;), regexes, fullMatches, patterns);</span>

<span class="fc" id="L118">        validateConfiguration(false, fullMatches, patterns, regexes);</span>

<span class="fc" id="L120">        this.includeTest = composeTest(fullMatches, patterns);</span>

<span class="pc bpc" id="L122" title="1 of 4 branches missed.">        doNothing = includeTest == null &amp;&amp; excludeTest == null;</span>
<span class="fc" id="L123">    }</span>

    protected abstract void validateConfiguration(boolean excludes, List&lt;String&gt; fullMatches, List&lt;Pattern&gt; patterns,
            boolean regexes);

    private void readMatches(ModelNode array, boolean regexes, List&lt;String&gt; fullMatches, List&lt;Pattern&gt; patterns) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (!array.isDefined()) {</span>
<span class="fc" id="L130">            return;</span>
        }

<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (ModelNode ann : array.asList()) {</span>
<span class="fc" id="L134">            String name = ann.asString();</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (regexes) {</span>
<span class="fc" id="L137">                patterns.add(Pattern.compile(name));</span>
            } else {
<span class="fc" id="L139">                fullMatches.add(name);</span>
            }
<span class="fc" id="L141">        }</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (!regexes) {</span>
<span class="fc" id="L144">            Collections.sort(fullMatches);</span>
        }
<span class="fc" id="L146">    }</span>


    @Override
    public boolean applies(@Nullable Element element) {
<span class="fc" id="L151">        return decide(element);</span>
    }

    @Override
    public boolean shouldDescendInto(@Nullable Object element) {
<span class="nc" id="L156">        return true;</span>
    }

    @SuppressWarnings(&quot;ConstantConditions&quot;)
    private boolean decide(@Nullable Object element) {
        //we don't exclude anything that we don't handle...
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">        if (doNothing || !(element instanceof JavaElement)) {</span>
<span class="fc" id="L163">            return true;</span>
        }

<span class="fc" id="L166">        InclusionState ret = elementResults.get(element);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (ret != null) {</span>
<span class="nc" id="L168">            return ret.toBoolean();</span>
        }

<span class="fc" id="L171">        JavaElement el = (JavaElement) element;</span>

        //exploit the fact that parent elements are always filtered before the children
<span class="fc" id="L174">        Element parent = el.getParent();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        InclusionState parentInclusionState = parent == null ? InclusionState.UNDECIDED</span>
<span class="fc" id="L176">                : elementResults.get(parent);</span>

        //if we have no record of the parent inclusion, then this is a top-level class. Assume it wants to be included.
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (parentInclusionState == null) {</span>
<span class="nc" id="L180">            parentInclusionState = InclusionState.UNDECIDED;</span>
        }

        //this is a java element, but not a model-based element - i.e. this is an annotation.
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (!(element instanceof JavaModelElement)) {</span>
<span class="fc" id="L185">            return decideAnnotation((JavaAnnotationElement) element, parentInclusionState);</span>
        }

<span class="fc" id="L188">        JavaModelElement javaElement = (JavaModelElement) element;</span>

<span class="fc" id="L190">        Stream&lt;String&gt; tested = getTestedElementRepresentations(javaElement);</span>

        //let's first assume we're going to inherit the parent's inclusion state
<span class="fc" id="L193">        ret = parentInclusionState;</span>

        //now see if we need to change that assumption
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        switch (parentInclusionState) {</span>
        case INCLUDED:
            //the parent was explicitly included in the results. We therefore only need to check if the annotations
            //on this element should be excluded
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (excludeTest != null) {</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                if (tested.anyMatch(s -&gt; excludeTest.test(s))) {</span>
<span class="fc" id="L202">                    ret = InclusionState.EXCLUDED;</span>
                }
            }
            break;
        case EXCLUDED:
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if (!canBeReIncluded(javaElement)) {</span>
<span class="nc" id="L208">                break;</span>
            }
            //the child element can be re-included, so the full suite of tests need to be run.
            //i.e. this fall-through is intentional.
        case UNDECIDED:
            //ok, the parent is undecided. This means we have to do the full checks on this element.
<span class="fc" id="L214">            List&lt;String&gt; testedList = null;</span>
<span class="fc bfc" id="L215" title="All 4 branches covered.">            if (includeTest != null &amp;&amp; excludeTest != null) {</span>
<span class="fc" id="L216">                testedList = tested.collect(toList());</span>
<span class="fc" id="L217">                tested = testedList.stream();</span>
            }

<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (includeTest != null) {</span>
                //ok, there is an include test but the parent is undecided. This means that the parent actually
                //didn't match the include test. Let's check with this element.
<span class="fc bfc" id="L223" title="All 2 branches covered.">                ret = tested.anyMatch(s -&gt; includeTest.test(s))</span>
                        ? InclusionState.INCLUDED
                        : InclusionState.EXCLUDED;
            }

<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (excludeTest != null) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (testedList != null) {</span>
<span class="fc" id="L230">                    tested = testedList.stream();</span>
                }

                //there is an exclude test but the parent is undecided. This means that the exclude check didn't
                //match the parent. Let's check again with this element.

<span class="fc bfc" id="L236" title="All 2 branches covered.">                if (tested.anyMatch(s -&gt; excludeTest.test(s))) {</span>
<span class="fc" id="L237">                    ret = InclusionState.EXCLUDED;</span>
                }
            }
            break;
        }

<span class="fc" id="L243">        elementResults.put(element, ret);</span>
<span class="fc" id="L244">        return ret.toBoolean();</span>
    }

    protected boolean decideAnnotation(JavaAnnotationElement annotation, InclusionState parentInclusionState) {
<span class="nc" id="L248">        return parentInclusionState.toBoolean();</span>
    }

    protected abstract boolean canBeReIncluded(JavaModelElement element);

    protected abstract Stream&lt;String&gt; getTestedElementRepresentations(JavaModelElement element);

<span class="pc" id="L255">    protected enum InclusionState {</span>
        /**
         * The element was explicitly determined to be included
         */
<span class="fc" id="L259">        INCLUDED,</span>

        /**
         * The element was explicitly determined to be excluded
         */
<span class="fc" id="L264">        EXCLUDED,</span>

        /**
         * There was no precise decision possible on the element
         */
<span class="fc" id="L269">        UNDECIDED;</span>


        boolean toBoolean() {
<span class="fc bfc" id="L273" title="All 2 branches covered.">            switch (this) {</span>
            case INCLUDED:
            case UNDECIDED:
<span class="fc" id="L276">                return true;</span>
            default:
<span class="fc" id="L278">                return false;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>